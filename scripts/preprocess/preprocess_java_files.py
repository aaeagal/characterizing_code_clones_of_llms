import re
import argparse
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
import os


def parse_arguments() -> dict:

    parser = argparse.ArgumentParser(description='Preprocess the Java files generated by the model.')

    parser.add_argument(
        '--leetcode_description', type=str, help='Prompt to send to the model', required=True
    )
    parser.add_argument(
        '--temperature', help='Temperature for the response generation', required=True
    )
    parser.add_argument(
        '--task', type=str, help='Task to perform (python2java, java2python, python, etc)', required=True  
    )
    parser.add_argument(
        '--sampling', type=str, help='Sampling method (twenty queries vs one query)', required=True
    )
    parser.add_argument(
        '--model', type=str, help='Model to use for the response generation', required=True
    )

    args = parser.parse_args()

    return args

def preprocess_combined_java_files(filepath: str) -> None:
    # -- Get the filepaths -- #
    combined_file_path = os.path.join(filepath, "llm_generated/generated.java")
    
    # -- Read the combined file -- #
    with open(combined_file_path, "r") as file:
        combined_content = file.read()
    # -- Split the classes based on the "class Solution" keyword -- #
    if "public class Solution" in combined_content:
        classes = re.split(r"public class Solution\d*", combined_content)
    elif "class Solution" in combined_content:
        classes = re.split(r"class Solution\d*", combined_content)
    elif "public class Main" in combined_content:
        classes = re.split(r"public class Main", combined_content)
    elif "class Main" in combined_content:
        classes = re.split(r"class Main", combined_content)
    elif "public class Answer" in combined_content:
        classes = re.split(r"public class Answer", combined_content)
        only_answer = re.compile(r"Answer\d*")
        combined_content = only_answer.sub(f"Solution", combined_content)
    elif "class Answer" in combined_content:
        classes = re.split(r"class Answer", combined_content)
        only_answer = re.compile(r"Answer\d*")
        combined_content = only_answer.sub(f"Solution", combined_content)
    elif "class OutputString" in combined_content:
        classes = re.split(r"class OutputString", combined_content)
        only_output_string = re.compile(r"OutputString\d*")
        combined_content = only_output_string.sub(f"Solution", combined_content)

    for i, class_content in enumerate(classes):
        logging.info(f"Preprocessing Solution{i} for {filepath}")
        preprocessed_file_path = os.path.join(filepath, "preprocessed")
        preprocessed_file_path = os.path.join(preprocessed_file_path, f"Solution{i}")
        if i == 0:
            continue
        # -- Remove the import statements and the markdown code block -- #
        for line in class_content.split("\n"):
            if line.endswith(".") or "import" in line:
                # delete the import statements
                with open(f"/home/aeagal/characterizing_code_clones_of_llms/imports.txt", "a") as file:
                    file.write(line + "\n")
                class_content = class_content.replace(line, "")
        # -- Replace the class name with Solution{i} -- #
        pattern = re.compile(r"Solution\d*")
        class_content = pattern.sub(f"Solution{i}", class_content)
        only_output_string = re.compile(r"OutputString\d*")
        class_content = only_output_string.sub(f"Solution{i}", class_content)

        # -- Remove the clone number -- #
        pattern2 = r"Clone \d*:"
        class_content = re.sub(pattern2, "", class_content)
        pattern3 = r"\d*.* Java Code Clone \d*:"
        class_content = re.sub(pattern3, "", class_content)

        # -- Remove everything below the ``` -- # 
        if "```" in class_content:
            class_content = class_content.split("```")[0] 


        
        class_content = class_content.replace("```java", "")
        class_content = class_content.replace("```", "")


        # --- Create class content --- #
        class_content = f"import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Solution{i}" + class_content
        # -- Write the class to a file -- #
        if not os.path.exists(preprocessed_file_path):
            os.makedirs(preprocessed_file_path, exist_ok=True)
        with open(os.path.join(preprocessed_file_path, f"Solution{i}.java"), "w") as file:
            file.write(class_content)

def preprocess_separate_java_files(dirpath: str) -> None:
    
    for file in os.listdir(os.path.join(dirpath, "llm_generated")):
        main_flag = False
        logging.info(f"Preprocessing {file} for {dirpath}")
       
        # -- Get the filepaths -- #
        filepath= os.path.join(dirpath, "llm_generated", file)
        number_of_file = re.findall(r'\d+', file)[0]
        preprocessed_file_path = os.path.join(dirpath, "preprocessed")
        preprocessed_file_path = os.path.join(preprocessed_file_path, f"Solution{number_of_file}")

        # -- Read the separate file -- #
        with open(filepath, "r") as file:
            file_content = file.read()
        
        # -- Remove the import statements and the markdown code block -- #
        if "```java" in file_content and "```" in file_content:
            # get everything between the two markdown code blocks
            file_content = re.search(r'```java(.*?)```', file_content, re.DOTALL).group(1)
        
        if "```Java" in file_content and "```" in file_content:
            # get everything between the two markdown code blocks
            file_content = re.search(r'```Java(.*?)```', file_content, re.DOTALL).group(1)

        # -- Remove the import statements and the markdown code block -- #
        for line in file_content.split("\n"):
            if "import" in line:
                # delete the import statements
                with open(f"/home/aeagal/characterizing_code_clones_of_llms/imports.txt", "a") as file:
                    file.write(line + "\n")
                file_content = file_content.replace(line, "")
                
            if "```java" in line:
                # delete the markdown code block
                file_content = file_content.replace(line, "")
            if "```" in line:
                # delete the markdown code block
                file_content = file_content.replace(line, "")
        
        # --- Create class content --- #
        pattern = re.compile(r"Solution\d*")
        file_content = pattern.sub(f"Solution{number_of_file}", file_content)
        pattern2 = r"Clone \d*:"
        file_content = re.sub(pattern2, "", file_content)
        pattern3 = r"\d*.* Java Code Clone \d*:"
        file_content = re.sub(pattern3, "", file_content)
        file_content = f"import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\n" + file_content

        # --- Put Main Class in a separate file and take it out of file_content --- #
        if "public class Main {" in file_content:
            main_flag = True
            main_class = re.split(r"public class Main {", file_content) 
        
            main_class_content = main_class[1]

            if "public class" in main_class_content:
                main_flag = False
                file_content = re.split(r"public class", main_class_content)
                main_class_content = file_content[0]
                file_content = 'import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\npublic class' + file_content[1]

                
                
            elif "class" in main_class_content:
                main_flag = False
                file_content = re.split(r"class", main_class_content)
                main_class_content = file_content[0]
                file_content = 'import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass' + file_content[1]
                


            # -- Write the main class to a file -- #
            if not os.path.exists(preprocessed_file_path):
                os.makedirs(preprocessed_file_path, exist_ok=True)
            
            with open(os.path.join(preprocessed_file_path, f"Main.java"), "w") as file:
                main_class_content = "import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\npublic class Main {" + main_class_content
                file.write(main_class_content)

        elif "class Main {" in file_content:
            main_flag = True
            main_class = re.split(r"class Main {", file_content) 
            main_class_content = main_class[1]

            # -- Write the main class to a file -- #
            if not os.path.exists(preprocessed_file_path):
                os.makedirs(preprocessed_file_path, exist_ok=True)
            
            with open(os.path.join(preprocessed_file_path, f"Main.java"), "w") as file:
                main_class_content = "import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Main {" + main_class_content
                file.write(main_class_content)
        public_answer_pattern = re.compile(r"public class Answer {")
        answer_pattern = re.compile(r"class Answer {")
        public_example_pattern = re.compile(r"public class Example {")
        example_pattern = re.compile(r"class Example {")
        public_clone_solution_pattern = re.compile(r"public class CloneSolution\d* {")
        clone_solution_pattern = re.compile(r"class CloneSolution\d* {")
        public_codeclone_pattern = re.compile(r"public class CodeClone\d* {")
        codeclone_pattern = re.compile(r"class CodeClone\d* {")
        public_different_solution_pattern = re.compile(r"public class DifferentSolution\d* {")
        different_solution_pattern = re.compile(r"class DifferentSolution\d* {")
        public_modified_solution_pattern = re.compile(r"public class ModifiedSolution\d* {")
        modified_solution_pattern = re.compile(r"class ModifiedSolution\d* {")
        public_unique_letters_pattern = re.compile(r"public class UniqueLetters\d* {")
        unique_letters_pattern = re.compile(r"class UniqueLetters\d* {")
        public_word_array_pattern = re.compile(r"public class WordArray\d* {")
        word_array_pattern = re.compile(r"class WordArray\d* {")
        public_processor_pattern = re.compile(r"public class Processor\d* {")
        processor_pattern = re.compile(r"class Processor\d* {")
        public_text_processor_pattern = re.compile(r"public class TextProcessor\d* {")
        text_processor_pattern = re.compile(r"class TextProcessor\d* {")
        public_number_processor_pattern = re.compile(r"public class Solution\d*Clone\d* {")
        number_processor_pattern = re.compile(r"class Solution\d*Clone\d* {")
        public_main_class_pattern = re.compile(r"public class MainClass\d* {")
        main_class_pattern = re.compile(r"class MainClass\d* {")
        public_clone_pattern = re.compile(r"public class Clone\d* {")
        clone_pattern = re.compile(r"class Clone\d* {")

        pattern = re.compile(
    r"(?:public )?class (Answer|Example|CloneSolution\d*|CodeClone\d*|DifferentSolution\d*|"
    r"ModifiedSolution\d*|UniqueLetters\d*|WordArray\d*|Processor\d*|TextProcessor\d*|"
    r"Solution\d*Clone\d*|MainClass\d*|Clone\d*) \{"
)
        


        if public_answer_pattern.search(file_content):
            # -- Replace Answer with Solution{number_of_file} -- #
            only_answer = re.compile(r"Answer\d*")
            file_content = only_answer.sub(f"Solution{number_of_file}", file_content)
        elif answer_pattern.search(file_content):
            # -- Replace Answer with Solution{number_of_file} -- #
            only_answer = re.compile(r"Answer\d*")
            file_content = only_answer.sub(f"Solution{number_of_file}", file_content)
        elif public_example_pattern.search(file_content):
            # -- Replace Example with Solution{number_of_file} -- #
            only_example = re.compile(r"Example\d*")
            file_content = only_example.sub(f"Solution{number_of_file}", file_content)
        elif example_pattern.search(file_content):
            # -- Replace Example with Solution{number_of_file} -- #
            only_example = re.compile(r"Example\d*")
            file_content = only_example.sub(f"Solution{number_of_file}", file_content)
        elif public_clone_solution_pattern.search(file_content):
            # -- Replace CloneSolution with Solution{number_of_file} -- #
            only_clone_solution = re.compile(r"CloneSolution\d*")
            file_content = only_clone_solution.sub(f"Solution{number_of_file}", file_content)
        elif clone_solution_pattern.search(file_content):
            # -- Replace CloneSolution with Solution{number_of_file} -- #
            only_clone_solution = re.compile(r"CloneSolution\d*")
            file_content = only_clone_solution.sub(f"Solution{number_of_file}", file_content)
        elif public_codeclone_pattern.search(file_content):
            # -- Replace CodeClone with Solution{number_of_file} -- #
            only_codeclone = re.compile(r"CodeClone\d*")
            file_content = only_codeclone.sub(f"Solution{number_of_file}", file_content)
        elif codeclone_pattern.search(file_content):
            # -- Replace CodeClone with Solution{number_of_file} -- #
            only_codeclone = re.compile(r"CodeClone\d*")
            file_content = only_codeclone.sub(f"Solution{number_of_file}", file_content)
        elif public_different_solution_pattern.search(file_content):
            # -- Replace DifferentSolution with Solution{number_of_file} -- #
            only_different_solution = re.compile(r"DifferentSolution\d*")
            file_content = only_different_solution.sub(f"Solution{number_of_file}", file_content)
        elif different_solution_pattern.search(file_content):
            # -- Replace DifferentSolution with Solution{number_of_file} -- #
            only_different_solution = re.compile(r"DifferentSolution\d*")
            file_content = only_different_solution.sub(f"Solution{number_of_file}", file_content)
        elif public_modified_solution_pattern.search(file_content):
            # -- Replace ModifiedSolution with Solution{number_of_file} -- #
            only_modified_solution = re.compile(r"ModifiedSolution\d*")
            file_content = only_modified_solution.sub(f"Solution{number_of_file}", file_content)
        elif modified_solution_pattern.search(file_content):
            # -- Replace ModifiedSolution with Solution{number_of_file} -- #
            only_modified_solution = re.compile(r"ModifiedSolution\d*")
            file_content = only_modified_solution.sub(f"Solution{number_of_file}", file_content)
        elif public_unique_letters_pattern.search(file_content):
            # -- Replace UniqueLetters with Solution{number_of_file} -- #
            only_unique_letters = re.compile(r"UniqueLetters\d*")
            file_content = only_unique_letters.sub(f"Solution{number_of_file}", file_content)
        elif unique_letters_pattern.search(file_content):
            # -- Replace UniqueLetters with Solution{number_of_file} -- #
            only_unique_letters = re.compile(r"UniqueLetters\d*")
            file_content = only_unique_letters.sub(f"Solution{number_of_file}", file_content)
        
        


        # -- Write the class to a file -- #
        if not os.path.exists(preprocessed_file_path):
            os.makedirs(preprocessed_file_path, exist_ok=True)
        
        with open(os.path.join(preprocessed_file_path, f"Solution{number_of_file}.java"), "w") as file:
            if main_flag:
                file.write(main_class[0])
            else:
                file.write(file_content)

def main():
    # -- Get the command line arguments -- #
    args = parse_arguments()
    task = args.task
    model = args.model
    leetcode = args.leetcode_description
    temperature = args.temperature
    sampling = args.sampling

    # -- Fix temperature bug -- #
    if temperature == "0" or temperature == "1" or temperature == "2":
        temperature = int(temperature)
    else:
        temperature = float(temperature)

    # -- Create the filepath -- #
    filepath = f"../../data/{leetcode}/{temperature}/{model}/{task}/{sampling}"
    
    
    # -- Preprocess Java Files -- #
    if sampling == "once":
        preprocess_combined_java_files(filepath)
    elif sampling == "repeated":
        preprocess_separate_java_files(filepath)
    
    
if __name__ == '__main__':
    main()