import re
import argparse
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
import os

def parse_arguments() -> dict:

    parser = argparse.ArgumentParser(description='Preprocess the Java files generated by the model.')

    parser.add_argument(
        '--leetcode_description', type=str, help='Prompt to send to the model', required=True
    )
    parser.add_argument(
        '--temperature', help='Temperature for the response generation', required=True
    )
    parser.add_argument(
        '--task', type=str, help='Task to perform (python2java, java2python, python, etc)', required=True  
    )
    parser.add_argument(
        '--sampling', type=str, help='Sampling method (twenty queries vs one query)', required=True
    )
    parser.add_argument(
        '--model', type=str, help='Model to use for the response generation', required=True
    )

    args = parser.parse_args()

    return args

def preprocess_combined_java_files(filepath: str) -> None:
    combined_file_path = os.path.join(filepath, "llm_generated/generated.java")
    
    with open(combined_file_path, "r") as file:
        combined_content = file.read()

    # Pattern to capture class declarations
    pattern = re.compile(r"(public\s+)?class\s+(\w+\d*)\s*\{")
    
    # Find all class declarations and process each
    start = 0
    number_of_file = 1
    for match in pattern.finditer(combined_content):
        # Get the content before this class declaration (if it's the first class, this will be empty)
        before_class_content = combined_content[start:match.start()]
        # The class declaration including optional "public" and the class name
        class_declaration = match.group(0)
        # The class name
        class_name = match.group(2)
        
        # Determine end of current class content (start of next class or end of file)
        end = match.end()
        next_match = next(pattern.finditer(combined_content[end:]), None)
        if next_match:
            end += next_match.start()
        else:
            end = len(combined_content)
        
        # Class content including its declaration
        class_content = combined_content[match.start():end]
        
        # Replace the class name in the class content
        new_class_name = f"Solution{number_of_file}"  # Make sure number_of_file is defined and updated accordingly
        class_content = re.sub(r"\b" + re.escape(class_name) + r"\b", new_class_name, class_content)
        
        # Remove everything after ``` in the class content
        if "```" in class_content:
            class_content = class_content.split("```")[0]

        # Remove anything below ''' in the class content
        if "'''" in class_content:
            class_content = class_content.split("'''")[0]
        
        # Remove the import statements
        import_pattern = r'^\s*\d*\.*\s*import.*\n?'
        class_content = re.sub(import_pattern, "", class_content, flags=re.MULTILINE)

        # Remove any lines that end with .
        period_pattern = r'^.*\.\s*$'
        class_content = re.sub(period_pattern, "", class_content, flags=re.MULTILINE)
        
        # Write or print the modified class content
        preprocessed_file_path = os.path.join(filepath, "preprocessed")
        preprocessed_file_path = os.path.join(preprocessed_file_path, f"Solution{number_of_file}")

        if not os.path.exists(preprocessed_file_path):
            os.makedirs(preprocessed_file_path, exist_ok=True)
        with open(os.path.join(preprocessed_file_path, f"Solution{number_of_file}.java"), "w") as file:
            class_content = f"import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\n" + class_content
            file.write(class_content)
        
        # Update start for the next iteration
        start = end
        number_of_file += 1

def preprocess_separate_java_files(dirpath: str) -> None:
    
    for file in os.listdir(os.path.join(dirpath, "llm_generated")):
        main_flag = False
        logging.info(f"Preprocessing {file} for {dirpath}")
       
        # -- Get the filepaths -- #
        filepath= os.path.join(dirpath, "llm_generated", file)
        number_of_file = re.findall(r'\d+', file)[0]
        preprocessed_file_path = os.path.join(dirpath, "preprocessed")
        preprocessed_file_path = os.path.join(preprocessed_file_path, f"Solution{number_of_file}")

        # -- Read the file -- #
        with open(filepath, "r") as file:
            file_content = file.read()
        
        # -- Remove the markdown code block -- #
        # Remove the markdown code block, handling variations of "Java" case
        markdown_regex = r"```[Jj]ava\n(.*?)```"
        matches = list(re.finditer(markdown_regex, file_content, re.DOTALL))
        processed_content = ""

        if matches:
            for match in matches:
                java_code = match.group(1).strip()
                processed_content += java_code + "\n"
                file_content = processed_content
        else:
            processed_content = file_content
            file_content = processed_content
    


        # -- Remove the import statements and the markdown markers-- #
        file_content = re.sub(r'^\s*import .+?;$', '', file_content, flags=re.MULTILINE)
        
        if "'''" in file_content:
            file_content = file_content.split("'''")[0]
        
        
 
        # --- Create class content --- #
        pattern = re.compile(r"Solution\d*")
        file_content = pattern.sub(f"Solution{number_of_file}", file_content)
        pattern2 = r"Clone \d*:"
        file_content = re.sub(pattern2, "", file_content)
        pattern3 = r"\d*.* Java Code Clone \d*:"
        file_content = re.sub(pattern3, "", file_content)

        file_content = f"import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\n" + file_content

        # --- Put Main Class in a separate file and take it out of file_content --- #
        if "public class Main {" in file_content:
            main_flag = True
            main_class = re.split(r"public class Main {", file_content) 
        
            main_class_content = main_class[1]

            if "public class" in main_class_content:
                main_flag = False
                file_content = re.split(r"public class", main_class_content)
                main_class_content = file_content[0]
                file_content = 'import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\npublic class' + file_content[1]

                
                
            elif "class" in main_class_content:
                main_flag = False
                file_content = re.split(r"class", main_class_content)
                main_class_content = file_content[0]
                file_content = 'import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass' + file_content[1]
                


            # -- Write the main class to a file -- #
            if not os.path.exists(preprocessed_file_path):
                os.makedirs(preprocessed_file_path, exist_ok=True)
            
            with open(os.path.join(preprocessed_file_path, f"Main.java"), "w") as file:
                main_class_content = "import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\npublic class Main {" + main_class_content
                file.write(main_class_content)

        elif "class Main {" in file_content:
            main_flag = True
            main_class = re.split(r"class Main {", file_content) 
            main_class_content = main_class[1]

            # -- Write the main class to a file -- #
            if not os.path.exists(preprocessed_file_path):
                os.makedirs(preprocessed_file_path, exist_ok=True)
            
            with open(os.path.join(preprocessed_file_path, f"Main.java"), "w") as file:
                main_class_content = "import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\nclass Main {" + main_class_content
                file.write(main_class_content)

        # Pattern to find the class name
        pattern = re.compile(r"(public\s+class\s+|class\s+)(\w+)")

        # Search for the class name
        match = pattern.search(file_content)
        if match:
            class_name = match.group(2)  # The actual class name captured by the regex
            # Replace all occurrences of the class name with 'Solution{number}'
            file_content = re.sub(r"\b" + class_name + r"\b", f"Solution{number_of_file}", file_content)

        # -- Write the class to a file -- #
        if not os.path.exists(preprocessed_file_path):
            os.makedirs(preprocessed_file_path, exist_ok=True)
        


        
        with open(os.path.join(preprocessed_file_path, f"Solution{number_of_file}.java"), "w") as file:
            if main_flag:
                if "class" in main_class[0]:
                    file.write(main_class[0])
                else:
                    os.remove(os.path.join(preprocessed_file_path, f"Solution{number_of_file}.java"))
            else:
                file.write(file_content)

def main():
    # -- Get the command line arguments -- #
    args = parse_arguments()
    task = args.task
    model = args.model
    leetcode = args.leetcode_description
    temperature = args.temperature
    sampling = args.sampling

    # -- Fix temperature bug -- #
    if temperature == "0" or temperature == "1" or temperature == "2":
        temperature = int(temperature)
    else:
        temperature = float(temperature)

    # -- Create the filepath -- #
    filepath = f"../../data/{leetcode}/{temperature}/{model}/{task}/{sampling}"
    
    
    # -- Preprocess Java Files -- #
    if sampling == "once":
        preprocess_combined_java_files(filepath)
    elif sampling == "repeated":
        preprocess_separate_java_files(filepath)
    
    
if __name__ == '__main__':
    main()