import argparse
import os
import subprocess
import json
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
import re

def parse_arguments() -> dict:

    parser = argparse.ArgumentParser(description='Preprocess the Java files generated by the model.')

    parser.add_argument(
        '--leetcode_description', type=str, help='Prompt to send to the model', required=True
    )
    parser.add_argument(
        '--temperature', help='Temperature for the response generation', required=True
    )
    parser.add_argument(
        '--task', type=str, help='Task to perform (python2java, java2python, python, etc)', required=True  
    )
    parser.add_argument(
        '--sampling', type=str, help='Sampling method (twenty queries vs one query)', required=True
    )
    parser.add_argument(
        '--model', type=str, help='Model to use for the response generation', required=True
    )

    args = parser.parse_args()

    return args

def get_solution_output(sol_dir_path: str, input: dict) -> dict:
    behavior = {}
    compiling_error = ''
    main_flag = False
    files = os.listdir(sol_dir_path)
    pattern = re.compile(r"Solution\d*.java")

    # If main.java exists and an element that matches the pattern exists, remove the main.java file
    if "Main.java" in files:
        for file in files:
            if pattern.match(file):
                main_flag = True
                files.remove("Main.java")
                break

    for file in files:
        # -- Skip the json file -- #
        if file.endswith('.json') or file.endswith('.class'):
            logging.info(f"Skipping {file}")
            continue
        
        # -- Get the necessary file information -- #
        executable_name = executable_name = file.split('/')[-1].split('.')[0]
        full_file_path = os.path.join(sol_dir_path, file)
        file_name = file.split('/')[-1].split('.')[0]

        # -- Compile the file -- #
        try:
            if file.endswith(".java"):
                if main_flag:
                    compile_process = subprocess.run(["javac", full_file_path, os.path.join(sol_dir_path, "Main.java")], check=True, capture_output=True, text=True)
                    logging.info(f"Compiled {file} with Main flag")
                else:
                    compile_process = subprocess.run(["javac", full_file_path], check=True, capture_output=True, text=True)
                    logging.info(f"Compiled {file} without Main flag")
            elif file.endswith(".cpp"):
                compile_process = subprocess.run(['g++', '-std=c++20', '-o', executable_name, file], capture_output=True, text=True)
                logging.info(f"Compiled {file}")
        except subprocess.CalledProcessError as e:
            logging.error(f"Compiling Error: {e.stderr}")
            compiling_error = e.stderr
            behavior.update({"compiling_error": compiling_error})


        # -- Run the file -- #
        counter = 0
        for key, value in input.items():
            for input_list in value:
                counter += 1
                input_str = " ".join(map(str, input_list))
                logging.info(f"Counter: {counter} with {input_str}")
                try:
                    if file.endswith('.py'):
                        output = subprocess.run(['python3', file], input=input_str, capture_output=True, text=True, timeout=300)
                    elif file.endswith('.java'):
                        if main_flag:
                            output = subprocess.run(["java", "-cp", sol_dir_path, "Main"], input=input_str, capture_output=True, text=True, timeout=300)
                        else:
                            output = subprocess.run(["java", "-cp", sol_dir_path, executable_name], input=input_str, capture_output=True, text=True, timeout=300)                    
                    elif file.endswith('.cpp'):
                        output = subprocess.run([f'./{executable_name}'], input=input_str, capture_output=True, text=True, timeout=300)
                    
                     # --- Store the output in the behavior dictionary --- #
                    if output.returncode != 0:
                        behavior.update({input_str: output.stderr})
                    else:
                        behavior.update({input_str: output.stdout})
                    if counter == 10:
                        logging.info(f'Finished 10 inputs for {file_name}')
                        return behavior
                except subprocess.TimeoutExpired:
                    logging.error(f'Timeout')
                    behavior.update({input_str: "Timeout"})
                    continue

        logging.info(f'Calculated behavior for {file_name}')


        # -- Remove the executable -- #
        if file.endswith('.cpp'):
            executable_name = file.split('/')[-1].split('.')[0]
            os.remove(executable_name)

    return behavior


def main():
    # -- Get the command line arguments -- #
    args = parse_arguments()
    task = args.task
    model = args.model
    leetcode = args.leetcode_description
    temperature = args.temperature
    sampling = args.sampling

    # -- Fix temperature bug -- #
    if temperature == "0" or temperature == "1" or temperature == "2":
        temperature = int(temperature)
    else:
        temperature = float(temperature)

    # -- Create the preprocessed filepath -- #
    filepath = f"../../data/{leetcode}/{temperature}/{model}/{task}/{sampling}/preprocessed"

    # -- Get input from json -- #
    with open(f"../../data/{leetcode}/input_corpus.json", "r") as file:
        input = json.load(file)

    # -- Get Solution output -- #
    sol_dirs = os.listdir(filepath)

    for sol_dir in sol_dirs:
        sol_dir_path = os.path.join(filepath, sol_dir)
        behavior = get_solution_output(sol_dir_path, input)

        # -- Write the behavior to a file -- #
        with open(os.path.join(sol_dir_path, "behavior.json"), "w") as file:
            json.dump(behavior, file, indent=4)
    

    

if __name__ == "__main__":
    main()